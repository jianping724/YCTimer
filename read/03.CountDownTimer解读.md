#### 目录介绍
- 01.基础介绍
- 02.来看一个问题
- 05.源码分析



### 01.基础介绍
- 简单介绍
    - 定时执行在一段时间后停止的倒计时，在倒计时执行过程中会在固定间隔时间得到通知。
- 参数
    - millisInFuture 从开始调用start()到倒计时完成并onFinish()方法被调用的毫秒数。（倒计时时间，单位毫秒）
    - countDownInterval 接收onTick(long)回调的间隔时间。（单位毫秒）
- 公共方法
    - public final void cancel ()
        - 取消倒计时（取消后，再次启动会重新开始倒计时）
    - public abstract void onFinish ()
        - 倒计时完成时被调用
    - public abstract void onTick (long millisUntilFinished)
        - 固定间隔被调用
        - 参数 millisUntilFinished 倒计时剩余时间。
    - public synchronized final CountDownTimer start ()
        - 启动倒计时
- **使用方法**
    ```
    CountDownTimer timer = new CountDownTimer(30000, 1000) {
        public void onTick(long millisUntilFinished) {

        }

        public void onFinish() {

        }
    }.start();
    ```


### 02.来看一个问题
- 先看案例代码，如下所示
    - 期待的效果是：“5-4-3-2-1-finish”或者“5-4-3-2-1-0”。这里，显示 0 和 finish 的时间应该是一致的，所以把 0 放在 onFinish() 里显示也可以。
    ```
    mCountDownTimer = new CountDownTimer(5000, 1000) {
        @Override
        public void onTick(long millisUntilFinished) {
            Log.i(TAG, "----倒计时----onTick--"+millisUntilFinished);
        }

        public void onFinish() {
            Log.i(TAG, "----倒计时----onFinish");
        }
    };
    ```
- 然后看一下打印日志，如下所示
    ```
    2020-08-05 10:04:28.742 17266-17266/com.yc.yctimer I/CountDownTimer: ----倒计时----onTick--5000
    2020-08-05 10:04:29.744 17266-17266/com.yc.yctimer I/CountDownTimer: ----倒计时----onTick--3998
    2020-08-05 10:04:30.746 17266-17266/com.yc.yctimer I/CountDownTimer: ----倒计时----onTick--2997
    2020-08-05 10:04:31.746 17266-17266/com.yc.yctimer I/CountDownTimer: ----倒计时----onTick--1996
    2020-08-05 10:04:32.747 17266-17266/com.yc.yctimer I/CountDownTimer: ----倒计时----onTick--995
    2020-08-05 10:04:33.747 17266-17266/com.yc.yctimer I/CountDownTimer: ----倒计时----onFinish
    2020-08-05 10:04:45.397 17266-17266/com.yc.yctimer I/CountDownTimer: ----倒计时----onTick--4999
    2020-08-05 10:04:46.398 17266-17266/com.yc.yctimer I/CountDownTimer: ----倒计时----onTick--3998
    2020-08-05 10:04:47.400 17266-17266/com.yc.yctimer I/CountDownTimer: ----倒计时----onTick--2996
    2020-08-05 10:04:48.402 17266-17266/com.yc.yctimer I/CountDownTimer: ----倒计时----onTick--1994
    2020-08-05 10:04:49.405 17266-17266/com.yc.yctimer I/CountDownTimer: ----倒计时----onTick--992
    2020-08-05 10:04:50.401 17266-17266/com.yc.yctimer I/CountDownTimer: ----倒计时----onFinish
    ```
- 可以看到有几个问题：
    - 问题1. 每次 onTick() 都会有几毫秒的误差，并不是期待的准确的 "5000, 4000, 3000, 2000, 1000, 0"。
    - 问题2. 多运行几次，就会发现这几毫秒的误差，导致了计算得出的剩余秒数并不准确，如果你的倒计时需要显示剩余秒数，就会发生 秒数跳跃/缺失 的情况（比如一开始从“4”开始显示——缺少“5”，或者直接从“5”跳到了“3”——缺少“4”）。
    - 问题3. 最后一次 onTick() 到 onFinish() 的间隔通常超过了 1 秒，差不多是 2 秒左右。如果你的倒计时在显示秒数，就能很明显的感觉到最后 1 秒停顿的时间很长。



### 05.源码分析
- 基本结构如下所示： *CountDownTimer* 这个类的基本结构（红色标明的为关键处，蓝色标明的为抽象函数，我们使用时必须进行实现）
    - ![Image.png](http://upload-images.jianshu.io/upload_images/4432347-440ec1a4ecf31938.png)
- 功能实现的关键部分在于 *mHandler*，下面我们来看一看 *mHandler* 的源码：
    ```
    // handles counting down
    private Handler mHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            synchronized (CountDownTimer.this) {
                if (mCancelled) {
                    return;
                }
                final long millisLeft = mStopTimeInFuture - SystemClock.elapsedRealtime();
                if (millisLeft <= 0) {
                    onFinish();
                } else if (millisLeft < mCountdownInterval) {
                    // no tick, just delay until done
                    sendMessageDelayed(obtainMessage(MSG), millisLeft);
                } else {
                    long lastTickStart = SystemClock.elapsedRealtime();
                    onTick(millisLeft);
                    // take into account user's onTick taking time to execute
                    long delay = lastTickStart + mCountdownInterval - SystemClock.elapsedRealtime();
                    // special case: user's onTick took more than interval to
                    // complete, skip to next interval
                    while (delay < 0) delay += mCountdownInterval;
                    sendMessageDelayed(obtainMessage(MSG), delay);
                }
            }
        }
    };
    ```
- 主要在处理对 *millisLeft* 剩余时间的判断，其中 *delay* 的处理需要注意，当 *onTick()* 方法耗时过长时会进行跳过，可以用如下的流程图来表示整个流程：
    - ![Image.png](https://upload-images.jianshu.io/upload_images/4432347-9bc944c15c3abe4d.png)
- **synchronized 关键字**
    - 值得注意的是，源码中 *cancle()*, *start()* 函数被 synchronized 修饰，*mHandler.handleMessage(Message msg)* 中代码段也被 **synchronized** 修饰，它主要是用来保证在同一时刻，至多只有一个线程执行该段代码
    - 主要有以下两个特点：
        - 当有一个线程访问某具体对象的一个被 **synchronized** 修饰的代码区域时，其它线程对该具体对象中所有被 **synchronized** 修饰的代码区域的访问都会被阻塞。
        - 当有一个线程访问某具体对象的一个被 **synchronized** 修饰的代码区域时，其它线程对该具体对象中没有被 **synchronized** 修饰的代码区域的访问仍会正常进行。



#### 参考博客
- https://blog.csdn.net/u013719138/article/details/79012459




